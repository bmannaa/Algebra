-- This Happy file was machine-generated by the BNF converter
{
{-# OPTIONS -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
module ParNewtonGrammar where
import AbsNewtonGrammar
import LexNewtonGrammar
import ErrM
}

%name pYP YP
%name pYP1 YP1
%name pTerm Term
%name pMon Mon
%name pXMon XMon
%name pYMon YMon
%name pSCoeff SCoeff
%name pCoeff Coeff
%name pCoeff1 Coeff1

-- no lexer declaration
%monad { Err } { thenM } { returnM }
%tokentype { Token }

%token 
 'X^' { PT _ (TS "X^") }
 'Y^' { PT _ (TS "Y^") }
 '+' { PT _ (TS "+") }
 '-' { PT _ (TS "-") }
 '/' { PT _ (TS "/") }
 '(' { PT _ (TS "(") }
 ')' { PT _ (TS ")") }

L_integ  { PT _ (TI $$) }
L_err    { _ }


%%

Integer :: { Integer } : L_integ  { (read $1) :: Integer }

YP :: { YP }
YP : YP YP1 { YPMulti $1 $2 } 
  | YP1 { $1 }


YP1 :: { YP }
YP1 : Term { YPSing $1 } 


Term :: { Term }
Term : SCoeff Mon { TermNonConst $1 $2 } 
  | SCoeff { TermConst $1 }


Mon :: { Mon }
Mon : XMon { MonomX $1 } 
  | YMon { MonomY $1 }
  | XMon YMon { MonomXY $1 $2 }


XMon :: { XMon }
XMon : 'X^' Integer { XMonom $2 } 


YMon :: { YMon }
YMon : 'Y^' Integer { YMonom $2 } 


SCoeff :: { SCoeff }
SCoeff : '+' Coeff { SCoeffP $2 } 
  | '-' Coeff { SCoeffM $2 }


Coeff :: { Coeff }
Coeff : Coeff1 '/' Coeff1 { CoeffR $1 $3 } 
  | Coeff1 { $1 }


Coeff1 :: { Coeff }
Coeff1 : Integer { CoeffI $1 } 
  | '(' Coeff ')' { $2 }



{

returnM :: a -> Err a
returnM = return

thenM :: Err a -> (a -> Err b) -> Err b
thenM = (>>=)

happyError :: [Token] -> Err a
happyError ts =
  Bad $ "syntax error at " ++ tokenPos ts ++ 
  case ts of
    [] -> []
    [Err _] -> " due to lexer error"
    _ -> " before " ++ unwords (map prToken (take 4 ts))

myLexer = tokens
}

